#pragma kernel CSMain

RWTexture2D<float4> Result;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float4 _DirectionalLight;

float2 _PixelOffset;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

static const float PI = 3.14159265f;
static const int FF = 0;
static const int FB = 1;

static const int CW = 0;
static const int CB = 1;

struct Sphere
{
	float3 position;
	float radius;
	float3 albedo;
	float3 specular;
};

StructuredBuffer<Sphere> _Spheres;


//-------------------------------------
//- RAY

struct Ray
{
	float3 origin;
	float3 direction;
	float3 energy;
};

Ray CreateRay(float3 origin, float3 direction)
{
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0f, 1.0f, 1.0f);
	return ray;
}

Ray CreateCameraRay(float2 uv)
{
	// Transform the camera origin to world space
	float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	direction = normalize(direction);

	return CreateRay(origin, direction);
}


//-------------------------------------
//- RAYHIT

struct RayHit
{
	float3 position;
	float distance;
	float3 normal;
	float3 albedo;
	float3 specular;
};

RayHit CreateRayHit()
{
	RayHit hit;
	hit.position = float3(0.0f, 0.0f, 0.0f);
	hit.distance = 1.#INF;
	hit.normal = float3(0.0f, 0.0f, 0.0f);
	hit.albedo = float3(0.0f, 0.0f, 0.0f);
	hit.specular = float3(0.0f, 0.0f, 0.0f);
	return hit;
}


//-------------------------------------
//- INTERSECTION

static const float EPSILON = 1e-8;

void IntersectTriangle(Ray ray, inout RayHit bestHit,float3 vert0, float3 vert1, float3 vert2, int FaceOrientation, int Color)
{

	float u, v, t;
	// find vectors for two edges sharing vert0
	if (FaceOrientation == FB) {
		float3 temp = vert0;
		vert0 = vert2;
		vert2 = temp;
	}

	float3 edge1 = vert1 - vert0;
	float3 edge2 = vert2 - vert0;

	// begin calculating determinant - also used to calculate U parameter
	float3 pvec = cross(ray.direction, edge2);

	// if determinant is near zero, ray lies in plane of triangle
	float det = dot(edge1, pvec);

	// use backface culling
	if (det < EPSILON)
		return ;
	float inv_det = 1.0f / det;

	// calculate distance from vert0 to ray origin
	float3 tvec = ray.origin - vert0;

	// calculate U parameter and test bounds
	u = dot(tvec, pvec) * inv_det;
	if (u < 0.0 || u > 1.0f)
		return ;

	// prepare to test V parameter
	float3 qvec = cross(tvec, edge1);

	// calculate V parameter and test bounds
	v = dot(ray.direction, qvec) * inv_det;
	if (v < 0.0 || u + v > 1.0f)
		return ;

	// calculate t, ray intersects triangle
	t = dot(edge2, qvec) * inv_det;

	if (t > 0 && t < bestHit.distance)
	{
		bestHit.distance = t;
		bestHit.position = ray.origin + t * ray.direction;
		bestHit.normal = normalize(cross(vert1 - vert0, vert2 - vert0));
		if (Color == CW) {

		//bestHit.albedo = .8f;
		bestHit.albedo = 1;
		bestHit.specular = 0.65f;
		}
		else {

			bestHit.albedo = 0.0;
			bestHit.specular = 0.0f;
		}

		
	}
}




void IntersectGroundPlane(Ray ray, inout RayHit bestHit)
{
	// Calculate distance along the ray where the ground plane is intersected
	float t = -ray.origin.y / ray.direction.y;
	if (t > 0 && t < bestHit.distance)
	{
		bestHit.distance = t;
		bestHit.position = ray.origin + t * ray.direction;
		bestHit.normal = float3(0.0f, 1.0f, 0.0f);
		bestHit.albedo = 0.8f;
		bestHit.specular = 0.03f;
	}
}

void IntersectSphere(Ray ray, inout RayHit bestHit, uint sphereIndex)
{
	// Calculate distance along the ray where the sphere is intersected
	Sphere sphere = _Spheres[sphereIndex];
	float3 d = ray.origin - sphere.position;
	float p1 = -dot(ray.direction, d);
	float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
	if (p2sqr < 0)
		return;
	float p2 = sqrt(p2sqr);
	float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
	if (t > 0 && t < bestHit.distance)
	{
		bestHit.distance = t;
		bestHit.position = ray.origin + t * ray.direction;
		bestHit.normal = normalize(bestHit.position - sphere.position);
		bestHit.albedo = sphere.albedo;
		bestHit.specular = sphere.specular;
	}
}

void ScalePentagon(float3 old_points[5], float offset, out float3 enlarged_points[5])
{
	float3 P = float3(0, 0, 0);
	for (int j = 0; j < 5; j++)
	{
		P += old_points[j];
	}
	P = P / 5;
	for (int j = 0; j < 5; j++)
	{
		enlarged_points[j] = old_points[j] * offset + (1 - offset)*P;
	}
}
void ScaleTriangle(float3 old_points[3], float offset, out float3 enlarged_points[3])
{
	float3 P = float3(0, 0, 0);
	for (int j = 0; j < 3; j++)
	{
		P += old_points[j];
	}
	P = P / 3;
	for (int j = 0; j < 3; j++)
	{
		enlarged_points[j] = old_points[j] * offset + (1 - offset)*P;
	}
}


void DrawTriangle(Ray ray, inout RayHit bestHit, float3 vert0,float3 vert1,float3 vert2, int FaceOrientation) {


	float3 vert[3]={
		vert0,
		vert1,
		vert2
	};
	float3 sclaedVert[3];

	float offset = 0.95;
	
	ScaleTriangle(vert, offset, sclaedVert);

	int indexes[4] = {
	0,1,2,0
	};


	IntersectTriangle(ray, bestHit, sclaedVert[0], sclaedVert[1], sclaedVert[2], FaceOrientation, CW);
//	IntersectTriangle(ray, bestHit, sclaedVert[0], sclaedVert[1], sclaedVert[2], FB,CW);
	
	for (int i = 0; i < 3; i++) {

		IntersectTriangle(ray, bestHit, vert[indexes[i]], vert[indexes[i+1]], sclaedVert[indexes[i ]], FF, CB);
		IntersectTriangle(ray, bestHit, sclaedVert[indexes[i ]], vert[indexes[i+1]], sclaedVert[indexes[i + 1]], FF, CB);	

		IntersectTriangle(ray, bestHit, vert[indexes[i]], vert[indexes[i + 1]], sclaedVert[indexes[i]], FB, CB);
		IntersectTriangle(ray, bestHit, sclaedVert[indexes[i ]], vert[indexes[i+1]], sclaedVert[indexes[i + 1]], FB, CB);
	}
}

void DrawSampleTriangle(Ray ray, inout RayHit bestHit) {
	float3 vert0 = float3(0, 0, 0)*10;
	float3 vert1 = float3(10, 5, 0) * 10;
	float3 vert2 = float3(-10, 5, 0) * 10;


	float3 vert[3]={
		vert0,
		vert1,
		vert2
	};
	float3 sclaedVert[3];
	float offset = 0.95;
	ScaleTriangle(vert, offset, sclaedVert);

	int indexes[4] = {
	0,1,2,0
	};



	IntersectTriangle(ray, bestHit, sclaedVert[0], sclaedVert[1], sclaedVert[2], FF, CW);
	IntersectTriangle(ray, bestHit, sclaedVert[0], sclaedVert[1], sclaedVert[2], FB,CW);
	
	for (int i = 0; i < 3; i++) {

		IntersectTriangle(ray, bestHit, vert[indexes[i]], vert[indexes[i+1]], sclaedVert[indexes[i ]], FF, CB);
		IntersectTriangle(ray, bestHit, sclaedVert[indexes[i ]], vert[indexes[i+1]], sclaedVert[indexes[i + 1]], FF, CB);	

		IntersectTriangle(ray, bestHit, vert[indexes[i]], vert[indexes[i + 1]], sclaedVert[indexes[i]], FB, CB);
		IntersectTriangle(ray, bestHit, sclaedVert[indexes[i ]], vert[indexes[i+1]], sclaedVert[indexes[i + 1]], FB, CB);
	}
}

void DrawTrianglePyramid(Ray ray, inout RayHit bestHit) {
	float3 k0, k1, k2, k3;
	float pointMulti = 150;

	k0 = float3(-pointMulti, -pointMulti, 0);
	k1 = float3(pointMulti, 0, 0);
	k2 = float3(0, pointMulti, 0);
	k3 = float3(0, 0, pointMulti);

	DrawTriangle(ray, bestHit, k0, k1, k2, FF); //OK
	DrawTriangle(ray, bestHit, k0, k3, k1, FF); //OK
	DrawTriangle(ray, bestHit, k0, k2, k3, FF); //OK
	DrawTriangle(ray, bestHit, k1, k3, k2, FF);
}
//-------------------------------------
//- TRACE

RayHit Trace(Ray ray)
{
	RayHit bestHit = CreateRayHit();

	// Trace ground plane
//	IntersectGroundPlane(ray, bestHit);

	// Trace triangle


	

	DrawTrianglePyramid(ray, bestHit);
	//DrawSampleTriangle(ray, bestHit);



	return bestHit;
}


//-------------------------------------
//- SHADE

float3 Shade(inout Ray ray, RayHit hit)
{
	if (hit.distance < 1.#INF)
	{
		// Reflect the ray and multiply energy with specular reflection
		ray.origin = hit.position + hit.normal * 0.001f;
		ray.direction = reflect(ray.direction, hit.normal);
		ray.energy *= hit.specular;

		//// Shadow test ray
		//bool shadow = false;
		//Ray shadowRay = CreateRay(hit.position + hit.normal * 0.001f, -1 * _DirectionalLight.xyz);
		//RayHit shadowHit = Trace(shadowRay);
		//if (shadowHit.distance != 1.#INF)
		//{
		//	return float3(0.0f, 0.0f, 0.0f);
		//}

		// Return a diffuse-shaded color
		return saturate(dot(hit.normal, _DirectionalLight.xyz) * -1) * _DirectionalLight.w * hit.albedo;
	}
	else
	{
		// Erase the ray's energy - the sky doesn't reflect anything
		ray.energy = 0.0f;

		// Sample the skybox and write it
		float theta = acos(ray.direction.y) / -PI;
		float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
		return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz * 1.8f;
	}
}


//-------------------------------------
//- KERNEL

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Get the dimensions of the RenderTexture
	uint width, height;
	Result.GetDimensions(width, height);

	// Transform pixel to [-1,1] range
	float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

	// Get a ray for the UVs
	Ray ray = CreateCameraRay(uv);

	// Trace and shade the ray
	float3 result = float3(0, 0, 0);

	for (int i = 0; i < 6; i++)
	{
		RayHit hit = Trace(ray);
		result += ray.energy * Shade(ray, hit);

		if (!any(ray.energy))
			break;
	}

	Result[id.xy] = float4(result.x,result.y,result.z, 1);
}
